
-- 1. Create Friend Requests Table
create table if not exists public.friend_requests (
  id uuid default gen_random_uuid() primary key,
  sender_id uuid references auth.users not null,
  receiver_id uuid references auth.users not null,
  status text default 'pending', -- pending, rejected
  created_at timestamp with time zone default now(),
  unique(sender_id, receiver_id) -- Prevent spamming requests
);

-- 2. Enable RLS
alter table public.friend_requests enable row level security;

-- 3. Policies for Requests

-- Users can see requests sent BY them or TO them
create policy "Users can view relevant requests."
  on friend_requests for select
  using ( auth.uid() = sender_id OR auth.uid() = receiver_id );

-- Users can insert requests (sending)
create policy "Users can send requests."
  on friend_requests for insert
  with check ( auth.uid() = sender_id );

-- Users can delete requests (canceling or rejecting)
create policy "Users can delete own requests."
  on friend_requests for delete
  using ( auth.uid() = sender_id OR auth.uid() = receiver_id );

-- 4. Secure Function to Accept Request (Atomic Transaction)
-- This function inserts the friendship into the main table (both ways) and removes the request.
CREATE OR REPLACE FUNCTION accept_friend_request(request_id uuid, friend_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- 1. Create bidirectional friendship
  -- (Me -> Them)
  INSERT INTO public.friendships (user_id, friend_id)
  VALUES (auth.uid(), friend_user_id)
  ON CONFLICT DO NOTHING;
  
  -- (Them -> Me)
  INSERT INTO public.friendships (user_id, friend_id)
  VALUES (friend_user_id, auth.uid())
  ON CONFLICT DO NOTHING;

  -- 2. Delete the request now that they are friends
  DELETE FROM public.friend_requests WHERE id = request_id;
END;
$$;
